---
sidebar_position: 1
---

<!-- import { FrameDisplay } from '../../src/components'; -->

# Tutorial: Introduction to DXOS

This tutorial doesn't assume any existing DXOS knowledge.

## Before We Start the Tutorial

The tutorial is divided into several sections:

- [Overview](#overview): will teach you the fundamentals of DXOS.
- [Developer Account Setup](#developer-account-setup): will teach you how to create a developer account on DXNS.
- [Create A Frame](#create-a-frame): will teach you how to create building blocks for peer-to-peer apps.
- [Deploy Frame](#deploy-frame): will teach you how to deploy your code to DXNS.

### What Are We Building?

In this tutorial, we'll show you how to build an interactive and collaborative tasks list with DXOS.

You can see what we'll be building here: [Final Result](https://codesandbox.io/TODO).

### Prerequisites

In this tutorial we will be assuming familiarity with React and related toolchains. While the DXOS stack itself does not depend on React, the all the official SDK packages are built for React at this point in time.

Before proceeding, make sure your system has the following installed:

- Node.js v16+
- Yarn v1.20+

## Overview

Now that you're setup, let's get an overview of DXOS!

### ECHO

TODO

### HALO

TODO

### MESH

TODO

### DXNS

TODO

## Developer Account Setup

In order to create domains and deploy to the DXNS registry you need to create a developer account. All of the actions taken in this section will be done using the DXOS CLI, so we will start by installing that.

### Install CLI

You can install the CLI globally using your favorite package manager, here we will use `yarn`:

```bash
yarn add --global @dxos/cli
```

Once the CLI is installed you should be able to run the following to see the version you installed:

```bash
dx version
```

The CLI has extensions which can be installed based on your needs. In this section we will make use of the DXNS extension, which can be installed by running the following:

```bash
dx extension install @dxos/cli-dxns
```

### Setup Profile

TODO: Update based on https://github.com/dxos/protocols/issues/860.

Profiles contain configuration for connecting with various DXOS services, allowing you to connect to specify which service provider you wish to use and quickly switch between them.

You can initialize our default profile with the following command:

```bash
dx profile init --name enterprise --template-url https://bit.ly/3A642xB
```

Once the profile has been initialized, set it as the current profile:

```bash
dx profile set enterprise
```

### Create Developer Account

Once you have setup a profile you can then create a developer account on the DXNS registry:

```bash
dx dxns account generate
```

After running this you will see the following output with a unique address and seed phrase:

```bash
key       value
--------  ----------------------------------------------------------------------------
mnemonic  eyebrow dust cry stove someone remind insane talk health slight swarm yellow
address   5EpqhyY9AfHgmrqwFs7tFh3V89ktNamgTP3TWM5zgeQM8y7a
```

In order to finish setting up your profile, copy the mnemonic and add it to your current profile. You can find your profile file in `~/.dx/profile/enterprise.yml`. Enter the mnemonic in the field `runtime.services.dxns.accountUri`.

### Fund Account

We will now add funds to your registry account so that you can purchase a domain. In order to do this you need the address of a faucet and an account address. You can find the address of your faucet in your profile config file, while your account address is taken from the output when you generated your account.

```bash
dx dxns balance increase --faucet https://dxns2.kube.dxos.network/kube/faucet --account 5EpqhyY9AfHgmrqwFs7tFh3V89ktNamgTP3TWM5zgeQM8y7a
```

You can check that your account has a balance by running the following command:

```bash
dx dxns balance get 5EpqhyY9AfHgmrqwFs7tFh3V89ktNamgTP3TWM5zgeQM8y7a
```

When you run that should see an output of:

```bash
key      value
-------  -------------
balance  1000000000000
```

### Domain

Now that you have funds in your account you'll be able to create domains in the registry. All records registered in the registry are created under a domain.

In order to registry a domain on DXNS you need to create an auction for it:

```bash
dx dxns auction create my-domain 1000000
```

After some time (approximately 10 minutes), you should be able to close the auction and claim that domain, assuming no one else has outbid you:

```bash
dx dxns auction close my-domain
dx dxns auction claim my-domain
```

It should prompt out a domain key:

```bash
key        value
---------  ----------------------------------------------------------------
domainKey  aaaaaaaaa0258fbf170edb873da49c9bd79fa258fa69abef5e8c55bcc020088e
```

While you are waiting for your auction to be able to be closed, we'll move on and circle back to this later.

### Devtools

Similar to React, DXOS has a devtools web extension. The devtools are not required to use DXOS or complete this tutorial but they will give extra insight into what is going on under the hood as you delve deeper into the DXOS ecosystem.

You can download a copy of the extension using the following command:

```bash
dx devtools download --from `dx dxns record get dxos:file.devtools --json | jq -r .data.hash`
```

This will download a zip file which can be [loaded as an unpacked extension](https://developer.chrome.com/docs/extensions/mv3/getstarted/#unpacked) to any Chromium-based browser.

TODO: Link

## Create A Frame

Now it's time build something! We're going to be building a simple but practical example of a tasks list.

In this section we will make use of another CLI extension, the app extension. You can install this extension by running:

```bash
dx extension install @dxos/cli-app
```

### What Is A Frame?

A frame is small application which can be loaded dynamically into a host application and interoperate with the host. At minimum a frame consists of a React component, then optionally defines additional functionality to facilitate interacting the host application and ECHO.

TODO: Link

### Setup Project

The easiest way to get started building a frame is to clone the frame template:

```bash
dx app create --template https://github.com/dxos/templates/tree/main/frame-template --path dxos-intro
```

Once you've cloned the template you'll want to install the dependencies:

```bash
cd dxos-intro
yarn
```

> Note: `yarn` is required here due to a dependency issue with `wrtc` which causes `npm install` to fail.

After the dependencies are installed you can run the storybook to see the placeholder frame content:

```bash
yarn book
```

> Note: the frame template does not use StorybookJS but a stripped down implementation of stories built using esbuild. The details are not included here as they are not relevant to this tutorial but you can find more information on this tool here: [@dxos/esbuild-server](https://github.com/dxos/esbuild-server).

### Update Dependencies

The first thing we need to do is add a couple of additional DXOS dependencies that we will need: `@dxos/object-model` and `@dxos/echo-db`. We want to match the version of the `@dxos/react-client` for these dependencies and they should be added to the `devDependencies` and `peerDependencies`. The reason we aren't adding these to the regular dependencies list is that we expect that they will be provided by the frame host whenever the frame is loaded. If they were non-standard dependencies we would want to add them to the `dependencies` list and bundle them with the frame.

TODO: Link.

After adding those dependencies to the `package.json`, don't forget to run `yarn` again to install them.

### Frame Manifest

The first thing we want to do is update our frame's manifest. In order to make an interactive frame we need to implement the `register` and `createRootItem` functions in the manifest. The `register` function should register any item models that the frame depends on, this will be called when the frame is loaded. The `createRootItem` function should create an item which corresponds to a single instance of the frame.

```tsx
import { ObjectModel } from '@dxos/object-model';

const TYPE_TASKS_LIST = 'example:type.tasks.list';

export const manifest: FrameManifest = {
  component: createFrame(Main),
  register: async (client) => {
    client.registerModel(ObjectModel);
  },
  createRootItem: async (party, props) => {
    const item = await party.database.createItem({
      model: ObjectModel,
      type: TYPE_TASKS_LIST,
      props
    });

    return item;
  }
};
```

### Implement Tasks List

Once we've got our dependencies updated we can start to work on implementing our tasks list. To start we'll add all the React and MUI dependencies we'll need.

```tsx
import React, { ChangeEvent, useState } from 'react';

import { Add as AddIcon } from '@mui/icons-material';
import {
  Box, Checkbox, IconButton, List, ListItem, ListItemIcon, ListItemSecondaryAction, ListItemText, TextField
} from '@mui/material';
```

Now lets start to setup the structure for our tasks list. We'll want a list and the first item in the list will be a text field to create new tasks. If you are still running the storybook, you should now be able to see a text field and icon rendered.

```tsx
return (
  <List dense>
    <ListItem>
      <ListItemIcon />
      <TextField
        fullWidth
        autoFocus
        variant='standard'
      />
      <ListItemSecondaryAction>
        <IconButton size='small'>
          <AddIcon />
        </IconButton>
      </ListItemSecondaryAction>
    </ListItem>
  </List>
);
```

Next we want to make our text field useful and add some tasks. The most important piece here is the `useFrameContext` hook. The frame context makes available an ECHO party and item to the frame -- parties and items are both ECHO primitives. In short, a party is a shared database containing queryable graph of items, while the item provided is the specific item relevant to your frame.

TODO: Link

We'll need both the party and item in order for the frame to operate properly so if either are missing we won't render anything for now.

There's also one other piece of state we need and that will be used to manage the new task input. With that in place we just need to go about creating tasks.

The last piece is an event handler which will create a new item in the party. This item has a few properties which we'll look at now:

- `type`: a string defined by us which will we can use to query for items later.
- `model`: defines the structure of the item (`ObjectModel` is the most common model, it behaves analogously to a Javascript object).
- `parent`: connects items in a parent-child relationship (eg. task list -> tasks)
- `props`: initial state of the item

```tsx
import { ObjectModel } from '@dxos/object-model';
import { useFrameContext } from '@dxos/react-framekit';

const TYPE_TASKS_TASK = 'example:type.tasks.task';

// ...

const { party, item } = useFrameContext();
const [newTask, setNewTask] = useState('');

if (!party || !item) {
  return null;
}

const handleCreateTask = async () => {
  if (!newTask.length) {
    return;
  }

  await party.database.createItem({
    type: TYPE_TASKS_TASK,
    model: ObjectModel,
    parent: item.id,
    props: {
      title: newTask
    }
  });

  setNewTask('');
};
```

Now we'll hook up the state and event handlers that we just defined with the text field.

```tsx
return (
  <List dense>
    <ListItem>
      <ListItemIcon />
      <TextField
        fullWidth
        autoFocus
        value={newTask}
        variant='standard'
        onChange={event => setNewTask(event.target.value)}
        onKeyPress={event => (event.key === 'Enter') && handleCreateTask()}
      />
      <ListItemSecondaryAction>
        <IconButton
          size='small'
          onClick={handleCreateTask}
        >
          <AddIcon />
        </IconButton>
      </ListItemSecondaryAction>
    </ListItem>
  </List>
);
```

With that in place you'll be able to create new tasks, but it still appears as if nothing is happening. We need to query the database to retrieve the tasks we create and render them. To query the database, we'll use the selection API from the party and the `useSelection` hook which returns a reactive result of the query.

TODO: Link

In our frame, we're specifically interested in items which are tasks, so we'll filter for only the tasks type that we defined earlier. Now we have a list of tasks which we can render in the tasks list.

<!-- Add filter by parent id once that is working in frames. -->

```tsx
import { useSelection } from '@dxos/react-client';

// ...

const tasks = useSelection(party?.database.select(selection => selection
  .filter({ type: TYPE_TASKS_TASK })
  .items
), [party, item]) ?? [];
```

```tsx
<Box>
  {tasks.map((item) => (
    <ListItem key={item.id}>
      <ListItemText primary={item.model.getProperty('title')} />
    </ListItem>
  ))}
</Box>
```

We're able to add tasks to our task list now, but a task list isn't very useful if you can't mark them as completed. Let's add a checkbox beside each of our tasks so that we can mark them as completed.

We'll store whether or not each task has been completed as a property on that item, similar to the title. When the checkbox is toggled correspondingly we'll toggle the completed property.

```tsx
import type { Item } from '@dxos/echo-db';

// ...

const handleToggleComplete = (item: Item<ObjectModel>) => async (event: ChangeEvent<HTMLInputElement>) => {
  await item.model.setProperty('complete', event.target.checked);
};

// ...

<ListItem key={item.id}>
  <ListItemIcon>
    <Checkbox
      checked={item.model.getProperty('complete') || false}
      onChange={handleToggleComplete(item)}
    />
  </ListItemIcon>
  <ListItemText primary={item.model.getProperty('title')} />
</ListItem>
```

That's it, we now have a fully functioning task list!

## Deploy Frame

Now that you have a functioning frame let's deploy it to the registry so that it can be used by you and others.

### Claim Domain

Circling back to your domain, if you haven't claimed it yet, now you can do so.

```bash
dx dxns auction close my-domain
dx dxns auction claim my-domain
```

### Update Config

Before deploying the frame you'll need to update the config file dx.yml.

There's a few fields in particular which need to be updated from the template:

- `name`: the DXN of your frame, starting with your domain followed by the name of your frame. By convention frame names start with `frame.`.
- `description`: what your frame is.
- `author`: your name or organization.
- `repository`: where the source of your frame is published.

```diff
 module:
   type: dxos:type.app
-  name: example:frame.template
-  description: Frame Starter Template
-  author: DXOS.org
+  name: my-domain:frame.tasks
+  description: Tasks List
+  author: Your Name
   license: AGPL-3.0
-  repository: 'https://github.com/dxos/braneframe/packages/frames/template-frame'
+  repository: 'https://github.com/my-account/tasks-frame'
```

### Deploy

Once you have updated the dx.yml file, you can deploy your frame to the registry. This will run the build command, publish the assets from the `out` directory to IPFS and create a new record in the registry tagged as `latest`.

```bash
dx dxns deploy --tag latest
```

> Note: The `latest` tag is a special tag which is the default loaded when no other tags or versions are specified.

### Ready For Action

Your frame is now deployed, let's try it out!

TODO <!-- <FrameDisplay /> -->

## What's Next?

TODO

- Try extending your tasks list frame to support deleting or editing tasks.
- Checkout Braneframe.
- Explore KUBE Console.
- Learn more about ECHO.
